# 排序演算法效能分析報告

## 一、時鐘精度

本程式使用 C++ 的 `<chrono>` 標準函式庫中的 `high_resolution_clock` 進行計時，使用 `duration_cast<microseconds>` 將執行時間換算為「微秒」(1 微秒 = 0.000001 秒)。這提供了足夠高的解析度以正確測量常見排序演算法在中等規模資料量（如 5000 筆資料）下的執行效能。

---

## 二、Heap Sort 最壞情況測試資料的隨機排列方式

為了模擬 Heap Sort 的最壞情況，本程式在 `makeCases()` 函數中對 HEAP 模式使用了 **隨機排列【Random Permutation】** 方式生成輸入資料：

```cpp
for (int i = CASE_ITEMS - 1; i >= 2; i--)
{
    int j = rand() % i + 1;
    swap(array[i], array[j]);
}
```

這段程式碼等像於 **Fisher-Yates shuffle** 隨機打亂法，使輸入數列在統計上接近 Heap Sort 的最壞或平均情況。

---

## 三、Merge Sort 最壞情況測試資料生成方式

Merge Sort 的最壞情況並不會明顯受特定輸入順序影響，因此程式中使用了 **遞減排序【由大至小】** 的資料生成方式作為最壞情況的模擬輸入：

```cpp
if (mode == "INSERTION" || mode == "QUICK" || mode == "MERGE")
    key = CASE_ITEMS - i;
```

這樣生成的輸入數列為遞減序列，例如 [5000, 4999, 4998, ..., 1]，對 Merge Sort 難以顯著抽慮效能，但可視為統一的 worst-case 測試資料來源。

---

## 四、所有測試資料的時間表（最壞情況 + 平均情況）

### 平均執行時間表格

| 資料數量 (n) | 插入排序 (Insertion) | 快速排序 (Quick) | 合併排序 (Merge) | 堆積排序 (Heap) |
|--------------|-----------------------|-------------------|------------------|-----------------|
| 500          | 419.2                 | 151.5             | 1921.1           | 73.8            |
| 1000         | 1688.7                | 609.7             | 4306.6           | 140.9           |
| 2000         | 6238.2                | 2264.2            | 11828.0          | 336.8           |
| 3000         | 14819.7               | 5525.9            | 17096.2          | 562.4           |
| 4000         | 23682.4               | 8861.6            | 24187.3          | 739.1           |
| 5000         | 38788.5               | 14426.6           | 30609.3          | 946.4           |

![image](https://github.com/Yangchenin41243245/Data_Structure_Homework_14_45/blob/main/pics/pic01.png)

### 時間複雜度趨勢分析

- 插入排序：明顯呈現 $O(n^2)$ 成長，效能下降快速。
- 快速排序：雖然最壞情況為 $O(n^2)$，但在平均情況下趨近 $O(n \log n)$，表現穩定。
- 合併排序：始終維持 $O(n \log n)$，在大型資料下表現穩定但稍高。
- 堆積排序：執行時間隨 $n$ 緩慢上升，符合 $O(n \log n)$，在此測試中表現最佳。

### 備註

所有時間皆為模擬測試平均值，可能因實作或環境略有變動。



