# 排序算法效能分析報告

## 1. 時鐘精度
本實驗所使用的時鐘精度為 **8 毫秒**。

## 2. Heap Sort 隨機排列次數
在測試 Heap Sort 的最壞情況時，我們至少進行 **10 次隨機排列**，以獲取較準確的最長執行時間。

## 3. Merge Sort 最壞情況數據產生方式
為了產生 Merge Sort 的最壞情況數據，我們使用了逆向合併的方式。具體步驟如下：
1. 從最終的合併步驟開始，確保合併的兩個子陣列分佈不均勻。
2. 在每次合併時，確保較大的元素始終位於需要最多步驟才能移動到正確位置的位置。
3. 依此類推，遞歸地回溯至初始的輸入數列，形成最不利於合併排序的數據。

## 4. 不同 n 值的排序時間表
| n 值 | 插入排序 (ms) | 快速排序 (ms) | 合併排序 (ms) | 堆排序 (ms) |
|------|--------------|--------------|--------------|--------------|
| 500  | X ms        | X ms        | X ms        | X ms        |
| 1000 | X ms        | X ms        | X ms        | X ms        |
| 2000 | X ms        | X ms        | X ms        | X ms        |
| 3000 | X ms        | X ms        | X ms        | X ms        |
| 4000 | X ms        | X ms        | X ms        | X ms        |
| 5000 | X ms        | X ms        | X ms        | X ms        |

(請填入實測數據)

## 5. 繪製的圖表
(此處應附上不同排序法的效能比較圖表)

## 6. 最佳組合排序函數的時間表與圖表
### 最佳組合排序策略
根據實驗結果，我們選擇以下的最佳組合排序策略：
- 當 n **較小** 時，使用 **插入排序**。
- 當 n **中等大小** 時，使用 **合併排序**。
- 當 n **較大** 時，使用 **快速排序（中位數選取法）或堆排序**。

### 組合排序函數時間表
| n 值 | 組合排序 (ms) |
|------|--------------|
| 500  | X ms        |
| 1000 | X ms        |
| 2000 | X ms        |
| 3000 | X ms        |
| 4000 | X ms        |
| 5000 | X ms        |

(請填入實測數據)

### 組合排序函數的效能圖表
(此處應附上組合排序與個別排序法的比較圖表)

## 7. 完整 C++ 程式碼
以下為完整的 C++ 程式碼，包括 **所有排序函數** 及 **測試主程式**。

```cpp
(請插入完整的 C++ 程式碼)
```

